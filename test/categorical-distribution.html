<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>QUnit test suite</title>
  <link rel="stylesheet" href="lib/qunit-1.13.0.css">
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>
  <script src="lib/qunit-1.13.0.js"></script>
  <script src="../categorical-distribution.js"></script>
  <script type="text/javascript">
    
    var unit = CategoricalDistribution;
    var util = CategoricalDistribution.util;

    var epsilon = 0.00001; // for floating point comparison

    var sum = function (array) {
      // Sum of the array
      var result = 0;
      for (var i = 0; i < array.length; i += 1) { result += array[i]; }
      return result;
    };

    var isAlmostEqual = function (a, b) {
      if (typeof a === 'number' && typeof b === 'number') {
        return (Math.abs(a - b) < epsilon);
      } // else
      return a === b;
    };
    
    var isAlmostDeepEqual = function (a, b) {
      // TODO recursive
      var i, equal;

      if (util.isArray(a)) {
        if (util.isArray(b)) {
          // Both are arrays
          if (a.length === b.length) {
            equal = true;
            for (i = 0; i < a.length && equal; i += 1) {
              equal = equal && isAlmostDeepEqual(a[i], b[i]);
            }
            return equal;
          } // else
          return false;
        } // else
        return false;
      } else if (typeof a === 'object') {
        if (typeof b === 'object') {
          // Both are objects
          equal = true;
          for (i in a) {
            if (a.hasOwnProperty(i) && b.hasOwnProperty(i)) {
              equal = equal && isAlmostDeepEqual(a[i], b[i]);
              if (!equal) {
                break;
              }
            } else {
              return false;
            }
          }
          return equal;
        }
      } else {
        return isAlmostEqual(a, b);
      }
    };

    var almostEqual = function (a, b, msg) {
      if (isAlmostEqual(a, b)) {
        ok(true, msg);
      } else {
        ok(false, msg + '\n' +
                  'Actual: ' + a + '\n' +
                  'Expected: ' + b);
      }
    };

    var almostDeepEqual = function (a, b, msg) {
      if (isAlmostDeepEqual(a, b)) {
        ok(true, msg);
      } else {
        ok(false, msg + '\n' +
                  'Actual: ' + JSON.stringify(a) + '\n' +
                  'Expected: ' + JSON.stringify(b));
      }
    };


    // Example distributions
    //   a, b: TODO


    test('initial state', function testCase() {
      // Test no throws
      var u = unit.create();
      ok(u.hasOwnProperty('state'));
      ok(u.state.hasOwnProperty('weights'));
    });

    test('dist basic', function testCase() {
      var u = unit.create(epsilon).dist({a: 3, b: 1}); // chaining test
      almostDeepEqual(u.prob(['a', 'b']), [0.75, 0.25]);
    });

    test('dist empty', function testCase() {
      var u = unit.create(epsilon);
      deepEqual(u.dist(), {}, 'Should be an empty object.');

      u.dist({a: 0, b: 0});
      deepEqual(u.dist(), {a: 0, b: 0}, 'Should have the cats.');
    });

    test('dist set when zero weightSum', function testCase() {
      var u = unit.create(epsilon).dist({a: 2, b: 1});
      u.learn(['a']);
      almostDeepEqual(u.prob(['a', 'b']), [0.75, 0.25]);
    });

    test('dist invalid', function testCase() {
      var u = unit.create();
      throws(function () {
        u.dist('foo');
      }, unit.InvalidDistributionException);

      throws(function () {
        u.dist({a: 3, b: 'foo'});
      }, unit.InvalidDistributionException);

      throws(function () {
        u.dist({a: 3, b: -1});
      }, unit.InvalidDistributionException);
    });

    test('dist infiltration', function testCase() {
      // Try to infiltrate through the distribution object.
      var u = unit.create();

      var d = {a: 3, b: 1};
      u.dist(d);
      almostDeepEqual(u.prob(), [0.75, 0.25]);
      d.a = 7;
      almostDeepEqual(u.prob(), [0.75, 0.25]);

      var e = u.dist();
      e.a = 7;
      almostDeepEqual(u.prob(), [0.75, 0.25]);
    });

    test('learn & prob & rank scalars', function testCase() {
      var u = unit.create(epsilon);
      // Use aa to find if strings are used as arrays by mistake.
      u.learn('aa').learn('b');
      almostEqual(u.prob('b'), 0.5);
      almostEqual(u.prob('aa'), 0.5);
      almostEqual(u.rank('b'), 0);
      almostEqual(u.rank('aa'), 1);
    });


    test('learn & prob & rank arrays', function testCase() {
      var u = unit.create(epsilon);
      u.learn(['aa', 'b']);
      almostDeepEqual(u.prob(['aa', 'b']), [0.5, 0.5]);
      almostDeepEqual(u.rank(['aa', 'b']), [1, 0]);
    });

    test('prob & rank without params', function testCase() {
      var u = unit.create(epsilon);
      u.learn(['red', 'green']);
      deepEqual(u.rank(), [0, 1]);
      almostDeepEqual(u.prob(), [0.5, 0.5]);
    });

    test('peak', function testCase() {
      var u = unit.create(epsilon);
      u.learn(['a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'c', 'c']);
      // P(a) = 0.5
      // P(b) = 0.3
      // P(c) = 0.2

      // tolerance 0.2 => min prob 0.5 - 0.5 * 0.2 = 0.4
      deepEqual(u.peak(0.2), ['a']);
      // tolerance 0.5 => min prob 0.5 - 0.5 * 0.5 = 0.25
      deepEqual(u.peak(0.5), ['a', 'b']);
      // tolerance 0.8 => min prob 0.5 - 0.5 * 0.8 = 0.1
      deepEqual(u.peak(0.8), ['a', 'b', 'c']);

      // Zero tolerance
      deepEqual(u.peak(0), ['a']);
    });

    test('peak out of range', function testCase() {
      var u = unit.create(epsilon);
      u.learn(['a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'c', 'c']);

      deepEqual(u.peak(-0.2), u.peak(0));
      deepEqual(u.peak(1.3), u.peak(1));
    });

    test('learn with mass', function testCase() {
      var u = unit.create(epsilon);
      u.learn('a', 3);
      u.learn('b');
      almostDeepEqual(u.prob(['a', 'b']), [0.75, 0.25]);
    });

    test('learn with mass 0', function testCase() {
      var u = unit.create();
      u.learn(['a', 'b'], 0);
      deepEqual(u.prob(['a', 'b']), [0, 0], 'Should have no effect');
    });

    test('learn with invalid massMultiplier', function testCase() {
      var u = unit.create();
      throws(function () {
        u.learn('a', '1');
      }, unit.InvalidMassException, 'Should be a number');
    });

    test('unlearn', function testCase() {
      var u = unit.create(epsilon);

      u.learn(['a', 'a', 'b']);
      almostDeepEqual(u.prob(['a', 'b']), [2/3, 1/3]);
      
      u.unlearn(['a']);
      almostDeepEqual(u.prob(['a', 'b']), [0.5, 0.5]);
    });

    test('unlearn scalar', function testCase() {
      var u = unit.create(epsilon);
      u.learn(['a', 'b']);
      u.unlearn('b');
      strictEqual(u.prob('b'), 0);
    });

    test('unlearn over', function testCase() {
      var u = unit.create(0.2);
      u.learn(['a', 'b']);   // + b
      u.unlearn(['b', 'b']); // - bb
      almostDeepEqual(u.prob(['a', 'b']), [1, 0]);
    });

    test('unlearn with mass', function testCase() {
      var u = unit.create(epsilon * 0.01);
      u.learn(['a', 'a', 'b'], 3);  // a 6, b 3
      u.unlearn(['a', 'b'], 2);     // a 4, b 1
      almostDeepEqual(u.prob(['a', 'b']), [0.8, 0.2]);
    });

    test('unlearn with mass 0', function testCase() {
      var u = unit.create(epsilon * 0.01);
      u.learn(['a', 'a', 'a', 'b'], 3); // a 9, b 3
      u.unlearn(['a', 'b'], 0);         // a 9, b 3, no effect
      almostDeepEqual(u.prob(['a', 'b']), [0.75, 0.25]);
    });

    test('unlearn with invalid mass', function testCase() {
      var u = unit.create();
      throws(function () {
        u.unlearn('a', '1');
      }, unit.InvalidMassException, 'Should be a number');
    });

    test('subset', function testCase() {

      var u = unit.create(epsilon);
      u.learn(['a', 'a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'd']);
      // P(a) = 0.4
      // P(b) = 0.3
      // P(c) = 0.2
      // P(d) = 0.1

      // min prob 0.15
      deepEqual(u.subset(['b', 'd']).peak(0.5), ['b']);
      // min prob 0.15
      deepEqual(u.subset(['b', 'c', 'd']).peak(0.5), ['b', 'c']);
      // min prob 0.08
      deepEqual(u.subset(['a', 'd']).peak(0.8), ['a', 'd']);

      // Zero tolerance
      deepEqual(u.subset(['b', 'd']).peak(0), ['b']);
    });

    test('subset scalar', function testCase() {
      var u = unit.create(epsilon);
      u.learn(['a', 'b']);
      strictEqual(u.subset('a').prob('a'), 1);
    });

    test('each', function testCase() {
      var u = unit.create();
      var numCategories = 0;
      u.learn(['a', 'a', 'b']);
      u.each(function (cat, prob, rank) {
        almostEqual(u.prob(cat), prob);
        strictEqual(u.rank(cat), rank);
        numCategories += 1;
      });
      strictEqual(numCategories, u.numCategories());
    });

    test('each with context', function testCase() {
      var u = unit.create();
      var ctx = {foo: 'bar'};
      u.learn(['a', 'a', 'b']);
      u.each(function (cat, prob, rank) {
        strictEqual(this.foo, 'bar');
      }, ctx);
    });

    test('map', function testCase() {
      var u = unit.create(epsilon);
      var numCategories = 0;
      u.learn(['a', 'a', 'b']);
      var head = u.map(function (cat, prob, rank) {
        almostEqual(u.prob(cat), prob);
        strictEqual(u.rank(cat), rank);
        return cat;
      });
      deepEqual(head, u.head());
      strictEqual(head.length, u.numCategories());
    });

    test('sample', function testCase() {
      // Non-deterministic test!!!
      // = May fail sometimes
      var u = unit.create(epsilon);
      u.learn(['a', 'b']);

      var i, s,
          na = 0, nb = 0,
          take = u.sample(10000);
      for (i = 0; i < take.length; i += 1) {
        s = take[i];
        if (s === 'a') {
          na += 1;
        } else if (s === 'b') {
          nb += 1;
        }
      }

      strictEqual(na + nb, 10000);
      ok(na > 4500, 'Fails sometimes but very rarely.');
      ok(nb > 4500, 'Fails sometimes but very rarely.');
    });

    test('sample, ordered', function testCase() {
      // Non-deterministic test!!!
      // = May fail sometimes
      var u = unit.create(epsilon);
      u.learn(['a', 'a', 'b']);

      var i, s,
          na = 0, nb = 0,
          take = u.sample(1000, true);

      // a's first
      for (i = 0; i < take.length; i += 1) {
        s = take[i];
        if (s === 'a') {
          na += 1;
        } else {
          break;
        }
      }
      strictEqual(i, na);

      // b's second
      for (; i < take.length; i += 1) {
        s = take[i];
        if (s === 'b') {
          nb += 1;
        } else {
          break;
        }
      }

      strictEqual(na + nb, 1000);
      ok(na > nb + 100, 'Fails sometimes but very rarely.');
    });

    test('sample size zero', function testCase() {
      var u = unit.create();
      u.learn(['a', 'a', 'b']);
      deepEqual(u.sample(0), []);
    });

    test('numCategories', function testCase() {
      var u = unit.create();
      u.learn(['a', 'b']);
      strictEqual(u.numCategories(), 2);
    });

    test('chaining', function testCase() {
      var u = unit.create(epsilon).learn(['aa','bb','aa']);
      var p = u.subset(['aa']).learn(['bb']).prob(['aa']);
      almostDeepEqual(p, [2/3]);
      
      p = u.each(function (cat) {
        u.unlearn([cat]);
      }).prob('aa');
      almostEqual(p, 1);
    });





    // Dump and load

    test('dumb & load', function testCase() {
      var u  = unit.create();
      var u2 = unit.create();
      u.learn(['a', 'a', 'b']);

      var dumped = u.dump();
      u2.load(dumped);
      
      deepEqual(u2.dump(), dumped);
      deepEqual(u2.head(), u.head());
      deepEqual(u2.rank(['a', 'b']), [0, 1]);
      strictEqual(u.adaptationRate(), u2.adaptationRate());
    });

    test('dump & load via JSON', function testCase() {
      // Tracks down possible incompability with JSON.
      // For example Infinity is not supported.

      var u1, u2, u3;

      u1  = unit.create();
      u2 = unit.create();
      u1.learn(['a', 'a', 'b']);
      var strDump = JSON.stringify(u1.dump());
      u2.load(JSON.parse(strDump));

      deepEqual(u1.dump(), u2.dump());
      deepEqual(u2.head(), u1.head());
      deepEqual(u2.rank(['a', 'b']), [0, 1]);
      strictEqual(u1.adaptationRate(), u2.adaptationRate());

      u3 = unit.create(0.2);
      u3.learn(['a', 'a', 'b']);
      var strDump = JSON.stringify(u3.dump());
      u2.load(JSON.parse(strDump));
      almostEqual(u2.adaptationRate(), 0.2);
    });

    test('load invalid', function testCase() {
      var u  = unit.create();
      var v = unit.create();
      u.learn(['a', 'a', 'b']);
      var tooShortDump = u.dump().slice(0, -1);

      throws(
        function () {
          v.load(tooShortDump);
        },
        unit.InvalidDumpException
      );
      
    });

    test('copy', function testCase() {
      var u = unit.create();
      u.learn(['a', 'b']);
      var u2 = u.copy();
      deepEqual(u2.rank(['a', 'b']), [1, 0]);
    });



    // Printing

    test('print', function testCase() {
      var u = unit.create(epsilon*epsilon*0.01).learn(['red','blue','blue']);
      var zero = 'blue 1\nred  0\n';
      var two = 'blue 0.67\nred  0.33\n';
      var three = 'blue 0.667\nred  0.333\n';
      var ten = 'blue 0.6666666667\nred  0.3333333333\n';
      strictEqual(u.print(), two);
      strictEqual(u.print(0), zero);
      strictEqual(u.print(3), three);

      // test: print with invalid precisions
      strictEqual(u.print(true), two);
      strictEqual(u.print(''), two);
      strictEqual(u.print(-1), zero);
      strictEqual(u.print(Infinity), ten);
      strictEqual(u.print(1000), ten);
    });

    test('print empty distribution', function testCase() {
      var u = unit.create();
      strictEqual(u.print(), '');
    });

    test('print categories of whitespaces', function testCase() {
      var u = unit.create(epsilon).learn(['\n', '']);
      strictEqual(u.print(), '  0.50\n\n 0.50\n');
    });

    



    // adaptationRate

    /*
    test('adaptationRate 0, min', function testCase() {
      var u = unit.create(0);
      u.learn(['a', 'b']);
      almostDeepEqual(u.prob(['a', 'b']), [0.5, 0.5]);

      // Still working if going back to default?
      u.adaptationRate(unit.DEFAULT_ADAPTATION_RATE);
      u.learn(['a', 'b']);
      almostDeepEqual(u.prob(['a', 'b']), [0.5, 0.5]);
    });

    test('adaptationRate 1, max', function testCase() {
      var u = unit.create(1);
      u.learn(['a', 'b']);
      strictEqual(u.adaptationRate(), 1); // Still the same
      deepEqual(u.prob(['a', 'b']), [0, 1]);
    });

    test('learningRate 2', function testCase() {
      var u = unit.create(2);
      u.learn(['a', 'b', 'c']);
      deepEqual(u.prob(['a', 'b', 'c']), [1/7, 2/7, 4/7]);
    });

    test('learningRate Infinity', function testCase() {
      var u = unit.create(Infinity);
      u.learn(['a', 'b', 'c']);
      deepEqual(u.prob(['a', 'b', 'c']), [0, 0, 1], 'Last should be all.');
    });

    test('learningRate negative', function testCase() {
      throws(function () {
        var u = unit.create(-1);
      }, unit.InvalidLearningRateException);
    });

    test('learningRate reset', function testCase() {
      var u = unit.create(1);
      u.learn(['a', 'b']);
      deepEqual(u.prob(['a', 'b']), [0.5, 0.5]);
      u.learningRate(Infinity);
      u.learn('a');
      deepEqual(u.prob(['a', 'b']), [1, 0]);
    });

    test('learningRate with learn & unlearn', function testCase() {
      // The inverse type of relation between learn and unlearn
      var u = unit.create(2);
      u.learn('a');
      var v = u.copy();
      var evs = ['a', 'b', 'b', 'a', 'b'];
      u.learn(evs);
      u.unlearn(evs.reverse());
      deepEqual(u.prob(['a', 'b']), v.prob(['a', 'b']));
    });

    test('eventWeight overflow', function testCase() {
      var u, p;
      u = unit.create(Math.pow(Number.MAX_VALUE, 0.6));
      u.learn('a');
      deepEqual(u.prob(['a', 'b']), [1, 0]);

      u.learn('b');
      pa = u.prob('b');
      pb = u.prob('b');
      // Unfortunately pb === 1
      ok(pa > 0, 'Should not be zero but is ' + p);
      ok(pb > 1 - epsilon, 'Should be close to 1 but is ' + p);
    });

    test('weightSum overflow', function testCase() {
      var LARGE, u, p;
      LARGE = Number.MAX_VALUE * 0.9;
      // LARGE + LARGE = Infinity
      u = unit.create(LARGE);
      u.learn('a'); // eventWeight turns large but no normalization
      u.learningRate(1);

      u.learn('b'); // without normalization weightsSum goes to Infinity
      deepEqual(u.prob(['a', 'b']), [0.5, 0.5]);
    });
    */




    // Customization

    test('customization', function testCase() {
      var u = unit.create();
      unit.extension.myFunction = function () {
        return 'foo';
      };
      strictEqual(u.myFunction(), 'foo');
    });



    
  </script>
</body>
</html>
